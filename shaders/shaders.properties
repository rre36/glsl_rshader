oldLighting=false
oldHandLight=false
vignette=false
separateAo=true
underwaterOverlay=false
sun=false
moon=true
fog=off

sliders=sunPathRotation shadowMapResolution sunlight_luma skylight_luma blocklight_luma minlight_luma \
vibrance_int saturation_int gamma_curve brightness_int constrast_int colorlum_r colorlum_g colorlum_b \
exposure_minlum exposure_speed manual_exposure \
vignette_start vignette_end vignette_intensity vignette_exponent

screen=INFO <profile> <empty> [Atmosphere] [Lighting] [World] [Post] [Misc]
    screen.Atmosphere=
    screen.Lighting=shadowMapResolution shadowfilter_hq <empty> [Effects] [Lights]
        screen.Effects=ambientOcclusion_enabled
        screen.Lights=sunlight_luma skylight_luma blocklight_luma minlight_luma
    screen.World=wind_effects_enabled wind_intensity
    screen.Post=taa_enabled image_sharpen <empty> [Exposure] [colorgrade] [Vignette] <empty> screenBitdepth
        screen.Exposure=exposure_minlum exposure_speed <empty> manual_exposure_enabled manual_exposure
        screen.colorgrade=do_colorgrading <empty> <empty> <empty> vibrance_int saturation_int gamma_curve brightness_int constrast_int <empty> colorlum_r colorlum_g colorlum_b
        screen.Vignette=vignette_enabled <empty> vignette_start vignette_end vignette_intensity vignette_exponent
    screen.Misc=*

screen.columns=1
screen.Atmosphere.columns=1
screen.Lighting.columns=1
screen.Effects.columns=1
screen.Lights.columns=1
screen.World.columns=1
screen.Post.columns=1
screen.Exposure.columns=1
screen.colorgrade.columns=2

program.world0/composite7.enabled=bloom_enabled
program.world0/composite8.enabled=bloom_enabled
program.world0/composite9.enabled=bloom_enabled
program.world0/composite10.enabled=bloom_enabled
program.world0/composite11.enabled=bloom_enabled

blend.gbuffers_basic=off
blend.gbuffers_block=off
blend.gbuffers_terrain=off
blend.gbuffers_entities=off
blend.gbuffers_hand=off
blend.gbuffers_spidereyes=SRC_ALPHA ONE ZERO ONE
blend.gbuffers_armor_glint=SRC_ALPHA ONE ZERO ONE
blend.gbuffers_textured=off
blend.gbuffers_skybasic=off
blend.gbuffers_skytextured=off
blend.gbuffers_textured_lit=off
blend.gbuffers_clouds=off
#blend.gbuffers_water=off
blend.deferred=off

texture.noise=tex/noise2D.png

uniform.vec2.viewSize = vec2(viewWidth, viewHeight)
uniform.vec2.pixelSize = vec2(1.0 / viewWidth, 1.0 / viewHeight)

variable.int.fmod8 = frameCounter % 8
uniform.vec2.taaOffset = vec2((if( \
    fmod8 == 0,  0.125, \
    fmod8 == 1, -0.125, \
    fmod8 == 2,  0.625, \
    fmod8 == 3,  0.375, \
    fmod8 == 4, -0.625, \
    fmod8 == 5, -0.875, \
    fmod8 == 6,  0.375, \
    fmod8 == 7,  0.875, \
    0.0)*0.6) / viewWidth, \
    (if( \
    fmod8 == 0, -0.375, \
    fmod8 == 1,  0.375, \
    fmod8 == 2,  0.125, \
    fmod8 == 3, -0.625, \
    fmod8 == 4,  0.625, \
    fmod8 == 5, -0.125, \
    fmod8 == 6, -0.875, \
    fmod8 == 7,  0.875, \
    0.0)*0.6) / viewHeight)


variable.float.upvecNorm    = 1.0 / sqrt((upPosition.x*upPosition.x) + (upPosition.y*upPosition.y) + (upPosition.z*upPosition.z))
uniform.vec3.upvecView      = vec3(upPosition.x*upvecNorm, upPosition.y*upvecNorm, upPosition.z*upvecNorm)
uniform.vec3.upvec          = vec3(0.0, 1.0, 0.0)

variable.float.sunvecNorm   = 1.0 / sqrt((sunPosition.x * sunPosition.x) + (sunPosition.y * sunPosition.y) + (sunPosition.z * sunPosition.z))
variable.float.svecX        = sunPosition.x * sunvecNorm
variable.float.svecY        = sunPosition.y * sunvecNorm
variable.float.svecZ        = sunPosition.z * sunvecNorm
uniform.vec3.sunvecView     = vec3(svecX, svecY, svecZ)
variable.float.sunvecX      = gbufferModelViewInverse.0.0 * sunPosition.x + gbufferModelViewInverse.1.0 * sunPosition.y + gbufferModelViewInverse.2.0 * sunPosition.z
variable.float.sunvecY      = gbufferModelViewInverse.0.1 * sunPosition.x + gbufferModelViewInverse.1.1 * sunPosition.y + gbufferModelViewInverse.2.1 * sunPosition.z
variable.float.sunvecZ      = gbufferModelViewInverse.0.2 * sunPosition.x + gbufferModelViewInverse.1.2 * sunPosition.y + gbufferModelViewInverse.2.2 * sunPosition.z
uniform.vec3.sunvec         = vec3(sunvecX * sunvecNorm, sunvecY * sunvecNorm, sunvecZ * sunvecNorm)

variable.float.moonvecNorm  = 1.0 / sqrt((moonPosition.x * moonPosition.x) + (moonPosition.y * moonPosition.y) + (moonPosition.z * moonPosition.z))
variable.float.mvecX        = moonPosition.x * moonvecNorm
variable.float.mvecY        = moonPosition.y * moonvecNorm
variable.float.mvecZ        = moonPosition.z * moonvecNorm
uniform.vec3.moonvecView    = vec3(mvecX, mvecY, mvecZ)
variable.float.moonvecX     = gbufferModelViewInverse.0.0 * moonPosition.x + gbufferModelViewInverse.1.0 * moonPosition.y + gbufferModelViewInverse.2.0 * moonPosition.z
variable.float.moonvecY     = gbufferModelViewInverse.0.1 * moonPosition.x + gbufferModelViewInverse.1.1 * moonPosition.y + gbufferModelViewInverse.2.1 * moonPosition.z
variable.float.moonvecZ     = gbufferModelViewInverse.0.2 * moonPosition.x + gbufferModelViewInverse.1.2 * moonPosition.y + gbufferModelViewInverse.2.2 * moonPosition.z
uniform.vec3.moonvec        = vec3(moonvecX * moonvecNorm, moonvecY * moonvecNorm, moonvecZ * moonvecNorm)

variable.float.lightvecNorm = 1.0 / sqrt((shadowLightPosition.x * shadowLightPosition.x) + (shadowLightPosition.y * shadowLightPosition.y) + (shadowLightPosition.z * shadowLightPosition.z))
uniform.vec3.lightvecView   = vec3(shadowLightPosition.x * lightvecNorm, shadowLightPosition.y * lightvecNorm, shadowLightPosition.z * lightvecNorm)
variable.float.lightvecX    = gbufferModelViewInverse.0.0 * shadowLightPosition.x + gbufferModelViewInverse.1.0 * shadowLightPosition.y + gbufferModelViewInverse.2.0 * shadowLightPosition.z
variable.float.lightvecY    = gbufferModelViewInverse.0.1 * shadowLightPosition.x + gbufferModelViewInverse.1.1 * shadowLightPosition.y + gbufferModelViewInverse.2.1 * shadowLightPosition.z
variable.float.lightvecZ    = gbufferModelViewInverse.0.2 * shadowLightPosition.x + gbufferModelViewInverse.1.2 * shadowLightPosition.y + gbufferModelViewInverse.2.2 * shadowLightPosition.z
uniform.vec3.lightvec       = vec3(lightvecX * lightvecNorm, lightvecY * lightvecNorm, lightvecZ * lightvecNorm)

variable.float.timeSunrise  = ((clamp(sunAngle, 0.97, 1.00) - 0.97) / 0.03) + (1.0 - (clamp(sunAngle, 0.01, 0.10) - 0.01) / 0.09)
variable.float.timeNoon     = ((clamp(sunAngle, 0.01, 0.10) - 0.01) / 0.09) - ((clamp(sunAngle, 0.40, 0.49) - 0.40) / 0.09)
variable.float.timeSunset   = ((clamp(sunAngle, 0.40, 0.49) - 0.40) / 0.09) - ((clamp(sunAngle, 0.50, 0.54) - 0.50) / 0.04)
variable.float.timeNight    = ((clamp(sunAngle, 0.50, 0.54) - 0.50) / 0.04) - ((clamp(sunAngle, 0.97, 1.00) - 0.97) / 0.03)
uniform.vec4.daytime        = vec4(timeSunrise, timeNoon, timeSunset, timeNight)

variable.bool.cloud_sunlit  = (worldTime>23000 || worldTime<12900)
uniform.vec3.cloud_lvec     = vec3(if(cloud_sunlit, sunvecX, moonvecX)*sunvecNorm, if(cloud_sunlit, sunvecY, moonvecY)*sunvecNorm, if(cloud_sunlit, sunvecZ, moonvecZ)*sunvecNorm)
uniform.vec3.cloud_lvecView = vec3(if(cloud_sunlit, svecX, mvecX), if(cloud_sunlit, svecY, mvecY), if(cloud_sunlit, svecZ, mvecZ))
variable.float.cloud_bsf1   = ((clamp(worldTime, 12550.0, 12800.0) - 12550.0) / 250.0) - ((clamp(worldTime, 23250.0, 23600.0) - 23250.0) / 350.0)
uniform.float.cloud_bsfade  = if(cloud_sunlit, 1.0-cloud_bsf1*0.75, 1.0)